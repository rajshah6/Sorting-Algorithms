/*
 * Name: Raj Shah
 * Date: August 15, 2023
 * Course: ICS4UE
 * Description: This program will sort an array of any size of random numbers between -1000 
 * to 1000 using 4 methods of the user's choice, selection sort, bubble sort,
 * insertion sort, or quick sort. The user can also choose to see the numbers
 * in ascending or descending order. The time taken for each sort will be displayed
 * to compare the efficiency of the sorting methods.
 */

import java.util.Random;

public class SortingRoutines extends javax.swing.JFrame {

    public SortingRoutines() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        numsToSort = new javax.swing.JTextField();
        userSortingAlgorithm = new javax.swing.JComboBox<>();
        userSortingOrder = new javax.swing.JComboBox<>();
        jLabel6 = new javax.swing.JLabel();
        sortBtn = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        sortedNumbers = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        originalNumbers = new javax.swing.JTextArea();
        jLabel9 = new javax.swing.JLabel();
        timeToSort = new javax.swing.JTextField();
        exitBtn = new javax.swing.JButton();
        errorBox = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sorting Routines");

        jLabel1.setFont(new java.awt.Font("Hiragino Sans GB", 0, 36)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(0, 51, 153));
        jLabel1.setText("Sorting Routines");

        jLabel2.setFont(new java.awt.Font("Helvetica Neue", 0, 24)); // NOI18N
        jLabel2.setText("Enter the following information:");

        jLabel3.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel3.setText("Sorting Algorithm: ");

        jLabel4.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel4.setText("Sorting Order: ");

        jLabel5.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel5.setText("Amount of numbers to sort: ");

        numsToSort.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N

        userSortingAlgorithm.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        userSortingAlgorithm.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Selection Sort", "Bubble Sort", "Insertion Sort", "Quick Sort" }));

        userSortingOrder.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        userSortingOrder.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Ascending", "Descending" }));

        jLabel6.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N

        sortBtn.setFont(new java.awt.Font("Helvetica Neue", 0, 24)); // NOI18N
        sortBtn.setText("SORT NUMBERS");
        sortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sortBtnActionPerformed(evt);
            }
        });

        jLabel7.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel7.setText("Original Numbers (Randomly generated)");

        jLabel8.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel8.setText("Sorted Numbers");

        sortedNumbers.setColumns(20);
        sortedNumbers.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        sortedNumbers.setRows(5);
        jScrollPane1.setViewportView(sortedNumbers);

        originalNumbers.setColumns(20);
        originalNumbers.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        originalNumbers.setRows(5);
        jScrollPane2.setViewportView(originalNumbers);

        jLabel9.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        jLabel9.setText("Time taken to sort (seconds): ");

        timeToSort.setEditable(false);
        timeToSort.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N

        exitBtn.setFont(new java.awt.Font("Helvetica Neue", 0, 24)); // NOI18N
        exitBtn.setText("Exit");
        exitBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitBtnActionPerformed(evt);
            }
        });

        errorBox.setEditable(false);
        errorBox.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        errorBox.setForeground(new java.awt.Color(255, 0, 51));
        errorBox.setHorizontalAlignment(javax.swing.JTextField.CENTER);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(294, 294, 294)
                .addComponent(jLabel2)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jLabel5)
                .addGap(18, 18, 18)
                .addComponent(numsToSort, javax.swing.GroupLayout.PREFERRED_SIZE, 119, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(285, 285, 285))
            .addGroup(layout.createSequentialGroup()
                .addGap(74, 74, 74)
                .addComponent(jLabel7)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel8)
                .addGap(174, 174, 174))
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(userSortingAlgorithm, javax.swing.GroupLayout.PREFERRED_SIZE, 164, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(userSortingOrder, javax.swing.GroupLayout.PREFERRED_SIZE, 152, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(47, 47, 47))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addGap(284, 284, 284)
                                .addComponent(jLabel1))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(324, 324, 324)
                                    .addComponent(sortBtn)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jLabel6))
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(26, 26, 26)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(185, 185, 185)
                                .addComponent(errorBox, javax.swing.GroupLayout.PREFERRED_SIZE, 481, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(128, 128, 128)
                                .addComponent(exitBtn)))
                        .addContainerGap(32, Short.MAX_VALUE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(212, 212, 212)
                .addComponent(jLabel9)
                .addGap(18, 18, 18)
                .addComponent(timeToSort, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel2)
                .addGap(41, 41, 41)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4)
                    .addComponent(userSortingAlgorithm, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(userSortingOrder, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(55, 55, 55)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(numsToSort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(54, 54, 54)
                        .addComponent(jLabel6)
                        .addGap(56, 56, 56))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sortBtn)
                        .addGap(42, 42, 42)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel7)
                    .addComponent(jLabel8))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 483, Short.MAX_VALUE)
                    .addComponent(jScrollPane1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 29, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel9)
                    .addComponent(timeToSort, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(exitBtn)
                    .addComponent(errorBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(26, 26, 26))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    // swap two numbers in an array
    private static void swap(int[] numbers, int indexA, int indexB) {
        int temp = numbers[indexA]; // store the number at indexA temporarily
        
        numbers[indexA] = numbers[indexB]; // set number at indexA to number at indexB
        numbers[indexB] = temp; // set number at indexB to number at indexA
    }
    
    // reverse numbers in an array
    private static void reverse(int[] numbers) {
        // set pointers
        int leftPointer = 0;
        int rightPointer = numbers.length - 1; 

        while (leftPointer < rightPointer) { // iterate through loop until left pointer is in the same spot as right pointer
            
            // swap elements at left and right indices
            swap(numbers, leftPointer, rightPointer);

            // move the pointers towards each other
            leftPointer++;
            rightPointer--;
        }
    } 
    
    // selection sort method
    public void selectionSort(int[] numbers) {
        double startTime = System.currentTimeMillis(); // start time when method is first ran
        
        int length = numbers.length;
        
        for (int i = 0; i < length - 1; i++) { // iterate through array
            int min = numbers[i]; // set initial min to position i in array
            int indexOfMin = i;
            
            for (int j = i + 1; j < length; j++) { // iterate through array again
                if (numbers[j] < min) {
                    min = numbers[j]; // find new minimum
                    indexOfMin = j;
                }
            }
            
            // swap numbers to put min at the start
            swap(numbers, i, indexOfMin); // swap numbers[i] with numbers[indexOfMin]
        }
        
        double endTime = System.currentTimeMillis(); // end time when method finishes sorting
        double time = (endTime - startTime) / 1000; // convert to seconds
        timeToSort.setText(time + ""); 
    }
    
    // bubble sort method
    public void bubbleSort(int[] numbers) {
        double startTime = System.currentTimeMillis(); // start time when method is first ran
        
        boolean swappedSomething = true; 
        while (swappedSomething) { // keep looping until all numbers are sorted
            swappedSomething = false; // at end of the for loop, if allSwapped is not set, this code will allow the while loop to end
            
            for (int i = 0; i < numbers.length - 1; i++) {
                if (numbers[i] > numbers[i+1]) { // if a larger number occures earlier then the next index, swap them
                    swappedSomething = true; // tell program that something has been swapped
                    swap(numbers, i, i+1); // swap numbers[i] with numbers[i+1]

                }
            }
        }
        
        double endTime = System.currentTimeMillis(); // end time when method finishes sorting
        double time = (endTime - startTime) / 1000; // convert to seconds
        timeToSort.setText(time + ""); 
    }
    
    // insertion sort method
    public void insertionSort(int[] numbers) {
        double startTime = System.currentTimeMillis(); // start time when method is first ran
        
        for (int i = 1; i < numbers.length; i++) { // start with second index in the array
            int currentValue = numbers[i];
            
            int j = i - 1; // get index right before the current index, i
            
            while (j >= 0 && numbers[j] > currentValue) { // go back to the beginning of the array index by index, and only stop once it reaches the beginning of the array or when it runs into a value that is less than the value we want to insert   
                numbers[j+1] = numbers[j]; // set the value at j+1 to one before that in the array
                j--; // decrement j to run through the array
            }
            
            numbers[j+1] = currentValue; // set the value at j+1 to what we set as the temporary variable
        }
        
        double endTime = System.currentTimeMillis(); // end time when method finishes sorting
        double time = (endTime - startTime) / 1000; // convert to seconds
        timeToSort.setText(time + ""); 
    }
    
    // quick sort method
    public void quickSort(int[] numbers, int lowIndex, int highIndex) { // low index and high index are needed as this is a recursive method, and the indicies will change as the method is called by itself
        double startTime = System.currentTimeMillis(); // start time when method is first ran
        
        if (lowIndex < highIndex) {
            int partitionIndex = partition(numbers, lowIndex, highIndex); // call partition method
            
            // recursively call method
            quickSort(numbers, lowIndex, partitionIndex - 1);
            quickSort(numbers, partitionIndex + 1, highIndex);
        }
        
        
        double endTime = System.currentTimeMillis(); // end time when method finishes sorting
        double time = (endTime - startTime) / 1000; // convert to seconds
        timeToSort.setText(time + ""); 
    }
    
    // partition method that will be called by the quick sort method
    public static int partition(int[] numbers, int lowIndex, int highIndex) {
        int i = lowIndex; // initialize left pointer i at the start of the sub-array
        int j = highIndex + 1; // initialize right pointer j just after the sub-array
        int pivot = numbers[lowIndex]; // choose the pivot element from the start of the sub-array

        do {
            do {
                i++; // move left pointer i to the right
                
            } while (i <= highIndex && numbers[i] < pivot); // continue while elements are less than pivot. ensure that pointer is less than or equal to the highest index of the array

            do {
                j--; // move right pointer j to the left
                
            } while (numbers[j] > pivot); // continue while elements are greater than pivot

            if (i < j) {
                // swap elements at indices i and j if i < j
                swap(numbers, i, j);
            }
            
        } while (i < j); // continue as long as left pointer is before right pointer

        // swap pivot element with element at index j (correct position)
        swap(numbers, lowIndex, j);

        // return the index where the pivot element is now positioned
        return j;
}
    
    
    private void sortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sortBtnActionPerformed
        // TODO add your handling code here:
        
        // reset output boxes
        errorBox.setText(""); 
        originalNumbers.setText("");
        sortedNumbers.setText("");
        timeToSort.setText("");
        
        String userInput = numsToSort.getText(); // get user input
        int length; // define length so it can be accessed outside of try catch
        
        try { // check for correct user input
            length = Integer.parseInt(userInput);
            
        } catch (Exception e) {
            errorBox.setText("Incorrect input. Please enter an integer.");
            return; // exit the method
        }
        
        if (length <= 0) { // check for positive input
            errorBox.setText("Input must be positive.");
            return; // exit the method
        }
        
        // initialize array of numbers 
        int[] numbers = new int[length];
        
        // create Random object
        Random random = new Random();
        
        // iterate through array and set random numbers inside the array
        for (int i = 0; i < length; i++) {
            numbers[i] = random.nextInt(2001) - 1000; // generates a random number from 0 to 2000, then subtracts 1000 to make the range -1000 to 1000
        }
        
        // display the unsorted array
        for (int number : numbers) { // obtain each value from array
            originalNumbers.append(number + "\n");
        }
        
        String sortingAlgorithm = (String) userSortingAlgorithm.getSelectedItem(); // get user input for sorting algorithm
        String sortingOrder = (String) userSortingOrder.getSelectedItem(); // get user input for sorting order
        
        // check which sorting algorithm is chosen
        switch (sortingAlgorithm) {
            
            // if the user chooses selection sort
            case "Selection Sort":
                
                if (sortingOrder.equals("Ascending")) {
                    selectionSort(numbers); // call sort method 
                    
                } else {
                    selectionSort(numbers); // call sort method
                    reverse(numbers); // reverse number order
                    
                } break;
            
            // if the user chooses bubble sort     
            case "Bubble Sort":
                
                if (sortingOrder.equals("Ascending")) {
                    bubbleSort(numbers); // call sort method 
                    
                } else {
                    bubbleSort(numbers); // call sort method
                    reverse(numbers); // reverse number order
                    
                } break;
                
            case "Insertion Sort":
                
                if (sortingOrder.equals("Ascending")) {
                    insertionSort(numbers); // call sort method 
                    
                } else {
                    insertionSort(numbers); // call sort method
                    reverse(numbers); // reverse number order
                    
                } break;
                
            default:
                
                if (sortingOrder.equals("Ascending")) {
                    quickSort(numbers, 0, length - 1); // call sort method 
                    
                } else {
                    quickSort(numbers, 0, length - 1); // call sort method
                    reverse(numbers); // reverse number order
                    
                } break;     
        }
        
        // display the sorted array
        for (int number : numbers) { // obtain each value from array
            sortedNumbers.append(number + "\n");
        }
        
    }//GEN-LAST:event_sortBtnActionPerformed

    private void exitBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitBtnActionPerformed
        // TODO add your handling code here:
        System.exit(0); // exit the program
    }//GEN-LAST:event_exitBtnActionPerformed

    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SortingRoutines().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField errorBox;
    private javax.swing.JButton exitBtn;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField numsToSort;
    private javax.swing.JTextArea originalNumbers;
    private javax.swing.JButton sortBtn;
    private javax.swing.JTextArea sortedNumbers;
    private javax.swing.JTextField timeToSort;
    private javax.swing.JComboBox<String> userSortingAlgorithm;
    private javax.swing.JComboBox<String> userSortingOrder;
    // End of variables declaration//GEN-END:variables
}
